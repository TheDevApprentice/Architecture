/**
 * Keycloak RBAC Automation Pipeline
 * 
 * Automatically assigns users to groups based on their attributes (department, role, etc.)
 * Uses mapping rules to determine appropriate group assignments
 */

// Load Keycloak library functions
def keycloakAuth
def keycloakUser
def keycloakGroup

pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ACTION',
            choices: [
                'APPLY_RBAC',
                'SYNC_USER_GROUPS',
                'SYNC_ALL_USERS',
                'VALIDATE_RULES',
                'DRY_RUN'
            ],
            description: 'Action to perform'
        )
        string(
            name: 'REALM',
            defaultValue: 'internal',
            description: 'Keycloak realm'
        )
        string(
            name: 'USERNAME',
            defaultValue: '',
            description: 'Username (for APPLY_RBAC or SYNC_USER_GROUPS)'
        )
        text(
            name: 'USERNAMES',
            defaultValue: '',
            description: 'List of usernames (one per line) for batch operations'
        )
        string(
            name: 'DEPARTMENT',
            defaultValue: '',
            description: 'Department attribute (e.g., IT, Engineering, Finance)'
        )
        string(
            name: 'ROLE',
            defaultValue: '',
            description: 'Role attribute (e.g., developer, admin, manager)'
        )
        booleanParam(
            name: 'REMOVE_UNMATCHED',
            defaultValue: false,
            description: 'Remove user from groups that don\'t match rules'
        )
    }
    
    environment {
        KC_URL_INTERNAL = "${KC_URL_INTERNAL}"
        KC_CLIENT_ID = "${KC_CLIENT_ID_JENKINS_AUTOMATION}"
        KC_CLIENT_SECRET = "${KC_SECRET_JENKINS_AUTOMATION}"
    }
    
    stages {
        stage('Load Keycloak Library') {
            steps {
                script {
                    // Load library scripts from filesystem
                    keycloakAuth = load '/var/jenkins_home/shared-library/vars/keycloakAuth.groovy'
                    keycloakUser = load '/var/jenkins_home/shared-library/vars/keycloakUser.groovy'
                    keycloakGroup = load '/var/jenkins_home/shared-library/vars/keycloakGroup.groovy'
                    echo "‚úÖ Keycloak library loaded successfully"
                }
            }
        }
        
        stage('Load RBAC Rules') {
            steps {
                script {
                    echo "üìã Loading RBAC mapping rules..."
                    
                    // RBAC Mapping Rules
                    // In production, this could be loaded from a config file or external system
                    env.RBAC_RULES = '''
{
  "IT": {
    "developer": ["IT", "Developers", "Jenkins-Users"],
    "admin": ["IT", "Admins", "Jenkins-Admins", "Infra"],
    "devops": ["IT", "DevOps", "Jenkins-Admins", "Docker-Users"],
    "manager": ["IT", "Managers", "Leads"]
  },
  "Engineering": {
    "developer": ["Engineering", "Developers"],
    "lead": ["Engineering", "Leads", "Developers"],
    "architect": ["Engineering", "Architects", "Leads"],
    "manager": ["Engineering", "Managers", "Leads"]
  },
  "Finance": {
    "analyst": ["Finance", "Analysts"],
    "accountant": ["Finance", "Accountants"],
    "manager": ["Finance", "Managers", "Leads"]
  },
  "HR": {
    "recruiter": ["HR", "Recruiters"],
    "manager": ["HR", "Managers", "Leads"]
  },
  "Sales": {
    "representative": ["Sales", "Representatives"],
    "manager": ["Sales", "Managers", "Leads"]
  }
}
'''
                    
                    def rules = readJSON(text: env.RBAC_RULES)
                    echo "‚úÖ Loaded RBAC rules for ${rules.keySet().size()} departments"
                    
                    // Display rules summary
                    echo "üìä RBAC Rules Summary:"
                    echo "=" * 80
                    rules.each { dept, roles ->
                        echo "  ${dept}:"
                        roles.each { role, groups ->
                            echo "    - ${role} ‚Üí ${groups.join(', ')}"
                        }
                    }
                    echo "=" * 80
                }
            }
        }
        
        stage('Validate Parameters') {
            steps {
                script {
                    echo "üîç Validating parameters..."
                    
                    if (!params.REALM) {
                        error("REALM parameter is required")
                    }
                    
                    if (params.ACTION in ['APPLY_RBAC', 'SYNC_USER_GROUPS'] && !params.USERNAME) {
                        error("USERNAME is required for ${params.ACTION}")
                    }
                    
                    if (params.ACTION == 'APPLY_RBAC' && (!params.DEPARTMENT || !params.ROLE)) {
                        error("Both DEPARTMENT and ROLE are required for APPLY_RBAC")
                    }
                    
                    echo "‚úÖ Parameters validated successfully"
                }
            }
        }
        
        stage('Get Access Token') {
            steps {
                script {
                    echo "üîê Obtaining Keycloak access token..."
                    env.ACCESS_TOKEN = keycloakAuth.getServiceAccountToken(
                        keycloakUrl: env.KC_URL_INTERNAL,
                        clientId: env.KC_CLIENT_ID,
                        clientSecret: env.KC_CLIENT_SECRET
                    )
                    echo "‚úÖ Access token obtained"
                }
            }
        }
        
        stage('Execute Action') {
            steps {
                script {
                    echo "üöÄ Executing action: ${params.ACTION}"
                    echo "=" * 80
                    
                    def rules = readJSON(text: env.RBAC_RULES)
                    
                    switch(params.ACTION) {
                        case 'APPLY_RBAC':
                            applyRbacToUser(
                                rules: rules,
                                username: params.USERNAME,
                                department: params.DEPARTMENT,
                                role: params.ROLE
                            )
                            break
                            
                        case 'SYNC_USER_GROUPS':
                            syncUserGroups(
                                rules: rules,
                                username: params.USERNAME,
                                removeUnmatched: params.REMOVE_UNMATCHED
                            )
                            break
                            
                        case 'SYNC_ALL_USERS':
                            syncAllUsers(
                                rules: rules,
                                removeUnmatched: params.REMOVE_UNMATCHED
                            )
                            break
                            
                        case 'VALIDATE_RULES':
                            validateRules(rules: rules)
                            break
                            
                        case 'DRY_RUN':
                            if (params.USERNAME) {
                                dryRunUser(
                                    rules: rules,
                                    username: params.USERNAME,
                                    department: params.DEPARTMENT,
                                    role: params.ROLE
                                )
                            } else {
                                echo "‚ö†Ô∏è  USERNAME is required for DRY_RUN"
                            }
                            break
                            
                        default:
                            error("Unknown action: ${params.ACTION}")
                    }
                    
                    echo "=" * 80
                    echo "‚úÖ Action '${params.ACTION}' completed successfully"
                }
            }
        }
    }
    
    post {
        success {
            echo "üéâ Pipeline completed successfully!"
        }
        failure {
            echo "‚ùå Pipeline failed!"
        }
        always {
            // Clean sensitive data
            env.ACCESS_TOKEN = null
        }
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

def applyRbacToUser(Map config) {
    def rules = config.rules
    def username = config.username
    def department = config.department
    def role = config.role
    
    echo "üîß Applying RBAC rules to user '${username}'..."
    echo "   Department: ${department}"
    echo "   Role: ${role}"
    
    // Get groups for this department + role
    if (!rules.containsKey(department)) {
        error("Department '${department}' not found in RBAC rules")
    }
    
    if (!rules[department].containsKey(role)) {
        error("Role '${role}' not found for department '${department}'")
    }
    
    def targetGroups = rules[department][role]
    
    echo "üìã Target groups: ${targetGroups.join(', ')}"
    
    // Add user to each target group
    def successCount = 0
    def failedGroups = []
    
    targetGroups.each { groupName ->
        try {
            // Check if group exists
            if (!keycloakGroup.groupExists(
                accessToken: env.ACCESS_TOKEN,
                groupName: groupName
            )) {
                echo "  ‚ö†Ô∏è  Group '${groupName}' does not exist, skipping"
                failedGroups << groupName
                return
            }
            
            // Add user to group
            keycloakGroup.addMembers(
                accessToken: env.ACCESS_TOKEN,
                groupName: groupName,
                usernames: [username]
            )
            
            successCount++
            
        } catch (Exception e) {
            echo "  ‚ùå Failed to add user to group '${groupName}': ${e.message}"
            failedGroups << groupName
        }
    }
    
    echo "‚úÖ Successfully added user to ${successCount}/${targetGroups.size()} groups"
    
    if (failedGroups.size() > 0) {
        echo "‚ö†Ô∏è  Failed groups: ${failedGroups.join(', ')}"
    }
    
    // Update user attributes
    try {
        keycloakUser.setUserAttributes(
            accessToken: env.ACCESS_TOKEN,
            username: username,
            attributes: [
                department: [department],
                role: [role],
                rbac_synced_at: [new Date().format("yyyy-MM-dd'T'HH:mm:ss'Z'")]
            ]
        )
        echo "‚úÖ Updated user attributes"
    } catch (Exception e) {
        echo "‚ö†Ô∏è  Failed to update user attributes: ${e.message}"
    }
}

def syncUserGroups(Map config) {
    def rules = config.rules
    def username = config.username
    def removeUnmatched = config.removeUnmatched
    
    echo "üîÑ Syncing groups for user '${username}'..."
    
    // Get user details to extract department and role attributes
    def user = keycloakUser.getUser(
        accessToken: env.ACCESS_TOKEN,
        username: username
    )
    
    if (!user) {
        error("User '${username}' not found")
    }
    
    def department = user.attributes?.department ? user.attributes.department[0] : null
    def role = user.attributes?.role ? user.attributes.role[0] : null
    
    if (!department || !role) {
        echo "‚ö†Ô∏è  User '${username}' does not have department and/or role attributes set"
        echo "   Department: ${department ?: 'NOT SET'}"
        echo "   Role: ${role ?: 'NOT SET'}"
        return
    }
    
    echo "   Department: ${department}"
    echo "   Role: ${role}"
    
    // Apply RBAC rules
    applyRbacToUser(
        rules: rules,
        username: username,
        department: department,
        role: role
    )
}

def syncAllUsers(Map config) {
    def rules = config.rules
    def removeUnmatched = config.removeUnmatched
    
    echo "üîÑ Syncing groups for ALL users in realm '${params.REALM}'..."
    
    // Get all users
    def users = keycloakUser.listUsers(
        accessToken: env.ACCESS_TOKEN
    )
    
    echo "üìã Found ${users.size()} users to sync"
    
    def syncedCount = 0
    def skippedCount = 0
    def failedCount = 0
    
    users.each { user ->
        try {
            def department = user.attributes?.department ? user.attributes.department[0] : null
            def role = user.attributes?.role ? user.attributes.role[0] : null
            
            if (!department || !role) {
                echo "  ‚è≠Ô∏è  Skipping '${user.username}' (missing attributes)"
                skippedCount++
                return
            }
            
            echo "  üîÑ Syncing '${user.username}' (${department}/${role})..."
            
            applyRbacToUser(
                rules: rules,
                username: user.username,
                department: department,
                role: role
            )
            
            syncedCount++
            
        } catch (Exception e) {
            echo "  ‚ùå Failed to sync '${user.username}': ${e.message}"
            failedCount++
        }
    }
    
    echo "=" * 80
    echo "‚úÖ Sync completed:"
    echo "   Synced: ${syncedCount}"
    echo "   Skipped: ${skippedCount}"
    echo "   Failed: ${failedCount}"
    echo "   Total: ${users.size()}"
}

def validateRules(Map config) {
    def rules = config.rules
    
    echo "üîç Validating RBAC rules..."
    
    def totalRules = 0
    def validGroups = 0
    def invalidGroups = 0
    def missingGroups = []
    
    rules.each { department, roles ->
        roles.each { role, groups ->
            totalRules++
            
            groups.each { groupName ->
                // Check if group exists
                def exists = keycloakGroup.groupExists(
                    accessToken: env.ACCESS_TOKEN,
                    groupName: groupName
                )
                
                if (exists) {
                    validGroups++
                } else {
                    invalidGroups++
                    missingGroups << [department: department, role: role, group: groupName]
                    echo "  ‚ö†Ô∏è  Group '${groupName}' referenced in ${department}/${role} does not exist"
                }
            }
        }
    }
    
    echo "=" * 80
    echo "üìä Validation Results:"
    echo "   Total rules: ${totalRules}"
    echo "   Valid groups: ${validGroups}"
    echo "   Missing groups: ${invalidGroups}"
    
    if (missingGroups.size() > 0) {
        echo ""
        echo "‚ö†Ô∏è  Missing Groups:"
        missingGroups.each { missing ->
            echo "   - ${missing.group} (${missing.department}/${missing.role})"
        }
    } else {
        echo "   ‚úÖ All groups exist!"
    }
    echo "=" * 80
}

def dryRunUser(Map config) {
    def rules = config.rules
    def username = config.username
    def department = config.department
    def role = config.role
    
    echo "üîç DRY RUN for user '${username}'..."
    echo "   Department: ${department}"
    echo "   Role: ${role}"
    
    if (!rules.containsKey(department)) {
        echo "‚ùå Department '${department}' not found in RBAC rules"
        return
    }
    
    if (!rules[department].containsKey(role)) {
        echo "‚ùå Role '${role}' not found for department '${department}'"
        return
    }
    
    def targetGroups = rules[department][role]
    
    echo "=" * 80
    echo "üìã Would assign user to the following groups:"
    targetGroups.each { groupName ->
        def exists = keycloakGroup.groupExists(
            accessToken: env.ACCESS_TOKEN,
            groupName: groupName
        )
        
        if (exists) {
            echo "   ‚úÖ ${groupName}"
        } else {
            echo "   ‚ùå ${groupName} (does not exist)"
        }
    }
    echo "=" * 80
}
