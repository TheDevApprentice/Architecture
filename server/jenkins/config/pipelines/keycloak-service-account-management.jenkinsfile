/**
 * Keycloak Service Account Management Pipeline
 * 
 * Management of service accounts (M2M clients) with secret rotation
 */

// Load Keycloak library functions
def keycloakAuth
def keycloakClient

pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ACTION',
            choices: [
                'CREATE_SERVICE_ACCOUNT',
                'LIST_SERVICE_ACCOUNTS',
                'GET_SERVICE_ACCOUNT',
                'DELETE_SERVICE_ACCOUNT',
                'ROTATE_SECRET',
                'GET_SA_TOKEN',
                'ENABLE_SA',
                'DISABLE_SA'
            ],
            description: 'Action to perform'
        )
        string(
            name: 'REALM',
            defaultValue: 'internal',
            description: 'Keycloak realm'
        )
        string(
            name: 'CLIENT_ID',
            defaultValue: '',
            description: 'Service account client ID (e.g., sa-jenkins-automation)'
        )
        string(
            name: 'DESCRIPTION',
            defaultValue: '',
            description: 'Service account description'
        )
        booleanParam(
            name: 'AUTO_ROTATE',
            defaultValue: false,
            description: 'Automatically rotate secret without approval'
        )
        booleanParam(
            name: 'DRY_RUN',
            defaultValue: false,
            description: 'Preview changes without executing'
        )
    }
    
    environment {
        KC_URL_INTERNAL = "${KC_URL_INTERNAL}"
        KC_CLIENT_ID = "${KC_CLIENT_ID_JENKINS_AUTOMATION}"
        KC_CLIENT_SECRET = "${KC_SECRET_JENKINS_AUTOMATION}"
    }
    
    stages {
        stage('Load Keycloak Library') {
            steps {
                script {
                    // Load library scripts from filesystem
                    keycloakAuth = load '/var/jenkins_home/shared-library/vars/keycloakAuth.groovy'
                    keycloakClient = load '/var/jenkins_home/shared-library/vars/keycloakClient.groovy'
                    echo "‚úÖ Keycloak library loaded successfully"
                }
            }
        }
        
        stage('Validate Parameters') {
            steps {
                script {
                    echo "üîç Validating parameters..."
                    
                    if (!params.REALM) {
                        error("REALM parameter is required")
                    }
                    
                    // Actions requiring CLIENT_ID
                    def actionsRequiringClient = [
                        'GET_SERVICE_ACCOUNT', 'DELETE_SERVICE_ACCOUNT',
                        'ROTATE_SECRET', 'GET_SA_TOKEN',
                        'ENABLE_SA', 'DISABLE_SA'
                    ]
                    
                    if (params.ACTION in actionsRequiringClient && !params.CLIENT_ID) {
                        error("CLIENT_ID is required for ${params.ACTION}")
                    }
                    
                    if (params.ACTION == 'CREATE_SERVICE_ACCOUNT' && !params.CLIENT_ID) {
                        error("CLIENT_ID is required for creating a service account")
                    }
                    
                    // Validate service account naming convention
                    if (params.ACTION == 'CREATE_SERVICE_ACCOUNT' && !params.CLIENT_ID.startsWith('sa-')) {
                        echo "‚ö†Ô∏è  WARNING: Service account names should start with 'sa-' (e.g., sa-jenkins-automation)"
                    }
                    
                    echo "‚úÖ Parameters validated successfully"
                }
            }
        }
        
        stage('Get Access Token') {
            steps {
                script {
                    echo "üîê Obtaining Keycloak access token..."
                    env.ACCESS_TOKEN = keycloakAuth.getServiceAccountToken(
                        keycloakUrl: env.KC_URL_INTERNAL,
                        clientId: env.KC_CLIENT_ID,
                        clientSecret: env.KC_CLIENT_SECRET
                    )
                    echo "‚úÖ Access token obtained"
                }
            }
        }
        
        stage('Execute Action') {
            steps {
                script {
                    echo "üöÄ Executing action: ${params.ACTION}"
                    echo "=" * 80
                    
                    switch(params.ACTION) {
                        case 'CREATE_SERVICE_ACCOUNT':
                            echo "üîß Creating service account '${params.CLIENT_ID}'..."
                            
                            def clientUuid = keycloakClient.createClient(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID,
                                protocol: 'openid-connect',
                                publicClient: false,
                                redirectUris: [],
                                webOrigins: [],
                                description: params.DESCRIPTION,
                                serviceAccountsEnabled: true,
                                standardFlowEnabled: false,
                                directAccessGrantsEnabled: false,
                                implicitFlowEnabled: false
                            )
                            
                            echo "‚úÖ Service account '${params.CLIENT_ID}' created successfully"
                            echo "   UUID: ${clientUuid}"
                            
                            // Get the generated secret
                            def secret = keycloakClient.getClientSecret(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID
                            )
                            
                            // Get the service account user
                            def saUser = keycloakClient.getServiceAccountUser(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID
                            )
                            
                            echo ""
                            echo "üìã Service Account Details:"
                            echo "=" * 80
                            echo "  Client ID: ${params.CLIENT_ID}"
                            echo "  Client Secret: ********${secret[-4..-1]}"
                            echo "  Service Account User: ${saUser.username}"
                            echo "  Service Account ID: ${saUser.id}"
                            echo "=" * 80
                            echo "‚ö†Ô∏è  IMPORTANT: Save the client secret securely!"
                            echo "‚ö†Ô∏è  Use this secret for M2M authentication (client_credentials grant)"
                            break
                            
                        case 'LIST_SERVICE_ACCOUNTS':
                            def clients = keycloakClient.listClients(
                                accessToken: env.ACCESS_TOKEN
                            )
                            
                            def serviceAccounts = clients.findAll { it.serviceAccountsEnabled }
                            
                            echo "üìã Service Accounts in realm '${params.REALM}':"
                            echo "=" * 80
                            serviceAccounts.each { sa ->
                                def status = sa.enabled ? '‚úÖ' : '‚ùå'
                                echo "  ${status} ${sa.clientId}"
                                if (sa.description) {
                                    echo "      Description: ${sa.description}"
                                }
                            }
                            echo "=" * 80
                            echo "Total: ${serviceAccounts.size()} service accounts"
                            break
                            
                        case 'GET_SERVICE_ACCOUNT':
                            def client = keycloakClient.getClient(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID
                            )
                            
                            if (!client.serviceAccountsEnabled) {
                                error("Client '${params.CLIENT_ID}' is not a service account")
                            }
                            
                            def saUser = keycloakClient.getServiceAccountUser(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID
                            )
                            
                            echo "üìä Service Account Details:"
                            echo "=" * 80
                            echo "  Client ID: ${client.clientId}"
                            echo "  UUID: ${client.id}"
                            echo "  Enabled: ${client.enabled}"
                            echo "  Description: ${client.description ?: 'N/A'}"
                            echo "  Service Account User: ${saUser.username}"
                            echo "  User ID: ${saUser.id}"
                            echo "  User Enabled: ${saUser.enabled}"
                            echo "=" * 80
                            break
                            
                        case 'DELETE_SERVICE_ACCOUNT':
                            // Approval gate for destructive action
                            if (!params.DRY_RUN) {
                                def client = keycloakClient.getClient(
                                    accessToken: env.ACCESS_TOKEN,
                                    clientId: params.CLIENT_ID
                                )
                                
                                if (!client.serviceAccountsEnabled) {
                                    error("Client '${params.CLIENT_ID}' is not a service account")
                                }
                                
                                echo "‚ö†Ô∏è  About to DELETE service account:"
                                echo "   Client ID: ${params.CLIENT_ID}"
                                echo "   UUID: ${client.id}"
                                
                                try {
                                    timeout(time: 5, unit: 'MINUTES') {
                                        input message: "‚ö†Ô∏è  Are you sure you want to DELETE service account '${params.CLIENT_ID}'?",
                                              ok: 'DELETE',
                                              submitter: 'admin'
                                    }
                                } catch (Exception e) {
                                    echo "‚ùå Delete operation cancelled by user"
                                    error("Operation cancelled")
                                }
                                
                                keycloakClient.deleteClient(
                                    accessToken: env.ACCESS_TOKEN,
                                    clientId: params.CLIENT_ID
                                )
                                
                                echo "‚úÖ Service account '${params.CLIENT_ID}' deleted successfully"
                            } else {
                                echo "üîç DRY RUN: Would delete service account '${params.CLIENT_ID}'"
                            }
                            break
                            
                        case 'ROTATE_SECRET':
                            if (!params.DRY_RUN) {
                                // Verify it's a service account
                                def client = keycloakClient.getClient(
                                    accessToken: env.ACCESS_TOKEN,
                                    clientId: params.CLIENT_ID
                                )
                                
                                if (!client.serviceAccountsEnabled) {
                                    error("Client '${params.CLIENT_ID}' is not a service account")
                                }
                                
                                // Get old secret for comparison
                                def oldSecret = keycloakClient.getClientSecret(
                                    accessToken: env.ACCESS_TOKEN,
                                    clientId: params.CLIENT_ID
                                )
                                
                                echo "üîÑ Starting secret rotation for '${params.CLIENT_ID}'..."
                                echo "=" * 80
                                echo "Step 1: Current secret: ********${oldSecret[-4..-1]}"
                                
                                // Approval gate unless auto-rotate is enabled
                                if (!params.AUTO_ROTATE) {
                                    echo "‚ö†Ô∏è  Manual approval required for secret rotation"
                                    try {
                                        timeout(time: 5, unit: 'MINUTES') {
                                            input message: "‚ö†Ô∏è  Rotate secret for '${params.CLIENT_ID}'? This will invalidate the current secret!",
                                                  ok: 'ROTATE',
                                                  submitter: 'admin'
                                        }
                                    } catch (Exception e) {
                                        echo "‚ùå Rotation cancelled by user"
                                        error("Operation cancelled")
                                    }
                                }
                                
                                echo "Step 2: Generating new secret..."
                                def newSecret = keycloakClient.regenerateSecret(
                                    accessToken: env.ACCESS_TOKEN,
                                    clientId: params.CLIENT_ID
                                )
                                
                                echo "Step 3: New secret: ********${newSecret[-4..-1]}"
                                echo "Step 4: Testing new secret..."
                                
                                // Test the new secret
                                try {
                                    def testToken = keycloakAuth.getServiceAccountToken(
                                        keycloakUrl: env.KC_URL_INTERNAL,
                                        clientId: params.CLIENT_ID,
                                        clientSecret: newSecret
                                    )
                                    
                                    if (testToken) {
                                        echo "‚úÖ New secret validated successfully"
                                    }
                                } catch (Exception e) {
                                    error("‚ùå Failed to validate new secret: ${e.message}")
                                }
                                
                                echo "=" * 80
                                echo "‚úÖ Secret rotation completed successfully!"
                                echo "üîê New secret: ********${newSecret[-4..-1]}"
                                echo "‚ö†Ô∏è  IMPORTANT: Update your application configuration with the new secret!"
                                echo "‚ö†Ô∏è  The old secret is now invalid and will no longer work."
                            } else {
                                echo "üîç DRY RUN: Would rotate secret for service account '${params.CLIENT_ID}'"
                            }
                            break
                            
                        case 'GET_SA_TOKEN':
                            echo "üîê Generating test token for service account '${params.CLIENT_ID}'..."
                            
                            // Get the secret
                            def secret = keycloakClient.getClientSecret(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID
                            )
                            
                            // Generate token using the service account credentials
                            def saToken = keycloakAuth.getServiceAccountToken(
                                keycloakUrl: env.KC_URL_INTERNAL,
                                clientId: params.CLIENT_ID,
                                clientSecret: secret
                            )
                            
                            if (saToken) {
                                echo "‚úÖ Token generated successfully"
                                echo "   Token (first 20 chars): ${saToken.take(20)}..."
                                echo "   Token length: ${saToken.length()} characters"
                                echo "‚ö†Ô∏è  Token is valid for the configured token lifespan"
                            }
                            break
                            
                        case 'ENABLE_SA':
                            keycloakClient.setClientEnabled(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID,
                                enabled: true
                            )
                            break
                            
                        case 'DISABLE_SA':
                            keycloakClient.setClientEnabled(
                                accessToken: env.ACCESS_TOKEN,
                                clientId: params.CLIENT_ID,
                                enabled: false
                            )
                            break
                            
                        default:
                            error("Unknown action: ${params.ACTION}")
                    }
                    
                    echo "=" * 80
                    echo "‚úÖ Action '${params.ACTION}' completed successfully"
                }
            }
        }
    }
    
    post {
        success {
            echo "üéâ Pipeline completed successfully!"
        }
        failure {
            echo "‚ùå Pipeline failed!"
        }
        always {
            // Clean sensitive data
            env.ACCESS_TOKEN = null
        }
    }
}
